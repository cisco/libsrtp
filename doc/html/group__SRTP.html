<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libSRTP: Secure RTP</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="docs.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSRTP
   &#160;<span id="projectnumber">2.1.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Secure RTP</div>  </div>
</div><!--header-->
<div class="contents">

<p>libSRTP provides functions for protecting RTP and RTCP. See Section Overview for an introduction to the use of the library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__SRTCP"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTCP.html">Secure RTCP</a></td></tr>
<tr class="memdesc:group__SRTCP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secure RTCP functions are used to protect RTCP traffic. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__User"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__User.html">data associated to a SRTP session.</a></td></tr>
<tr class="memdesc:group__User"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store custom user data within a SRTP session. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__SRTPevents"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTPevents.html">SRTP events and callbacks</a></td></tr>
<tr class="memdesc:group__SRTPevents"><td class="mdescLeft">&#160;</td><td class="mdescRight">libSRTP can use a user-provided callback function to handle events. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrtp__hdr__t.html">srtp_hdr_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrtp__hdr__xtnd__t.html">srtp_hdr_xtnd_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrtcp__hdr__t.html">srtcp_hdr_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrtcp__trailer__t.html">srtcp_trailer_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> describes a particular crypto policy that can be applied to an SRTP stream.  <a href="structsrtp__crypto__policy__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrtp__ssrc__t.html">srtp_ssrc_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="structsrtp__ssrc__t.html" title="An srtp_ssrc_t represents a particular SSRC value, or a `wildcard&#39; SSRC. ">srtp_ssrc_t</a> represents a particular SSRC value, or a `wildcard' SSRC.  <a href="structsrtp__ssrc__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrtp__master__key__t.html">srtp_master_key_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsrtp__master__key__t.html" title="srtp_master_key_t represents a master key. There will be a Master Key Index and the Master Key associ...">srtp_master_key_t</a> represents a master key. There will be a Master Key Index and the Master Key associated with the Master Key Index. Need to also keep track of the Master Key Index Size to correctly read it from a packet.  <a href="structsrtp__master__key__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the policy for an SRTP session.  <a href="structsrtp__policy__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga968bd496a57f1fed0f57f98e4264b0cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga968bd496a57f1fed0f57f98e4264b0cc">SRTP_MAX_MKI_LEN</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:ga968bd496a57f1fed0f57f98e4264b0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0737277d812a75053bd4f6446cb88b2d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga0737277d812a75053bd4f6446cb88b2d">SRTP_MAX_TRAILER_LEN</a>&#160;&#160;&#160;SRTP_MAX_TAG_LEN + <a class="el" href="group__SRTP.html#ga968bd496a57f1fed0f57f98e4264b0cc">SRTP_MAX_MKI_LEN</a></td></tr>
<tr class="memdesc:ga0737277d812a75053bd4f6446cb88b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the maximum number of octets added by <a class="el" href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2" title="srtp_protect() is the Secure RTP sender-side packet processing function. ">srtp_protect()</a>.  <a href="#ga0737277d812a75053bd4f6446cb88b2d">More...</a><br/></td></tr>
<tr class="separator:ga0737277d812a75053bd4f6446cb88b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65aa1c514841041428b54a629858217e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga65aa1c514841041428b54a629858217e">SRTP_MAX_NUM_MASTER_KEYS</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:ga65aa1c514841041428b54a629858217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf54c39ee78e2b6557c7e18b6e8afaf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga3cf54c39ee78e2b6557c7e18b6e8afaf">srtp_crypto_policy_set_aes_cm_128_hmac_sha1_80</a>(p)&#160;&#160;&#160;<a class="el" href="group__SRTP.html#ga5283f0bcdd44be2ec314077f74d831b0">srtp_crypto_policy_set_rtp_default</a>(p)</td></tr>
<tr class="memdesc:ga3cf54c39ee78e2b6557c7e18b6e8afaf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga3cf54c39ee78e2b6557c7e18b6e8afaf" title="srtp_crypto_policy_set_aes_cm_128_hmac_sha1_80() sets a crypto policy structure to the SRTP default p...">srtp_crypto_policy_set_aes_cm_128_hmac_sha1_80()</a> sets a crypto policy structure to the SRTP default policy for RTP protection.  <a href="#ga3cf54c39ee78e2b6557c7e18b6e8afaf">More...</a><br/></td></tr>
<tr class="separator:ga3cf54c39ee78e2b6557c7e18b6e8afaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad70c97ce681acb694ce3caee0c1051e4"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gad70c97ce681acb694ce3caee0c1051e4">srtp_cipher_type_id_t</a></td></tr>
<tr class="memdesc:gad70c97ce681acb694ce3caee0c1051e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A srtp_cipher_type_id_t is an identifier for a particular cipher type.  <a href="#gad70c97ce681acb694ce3caee0c1051e4">More...</a><br/></td></tr>
<tr class="separator:gad70c97ce681acb694ce3caee0c1051e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead974fea9c35a51c1dbf21aa136cd81"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaead974fea9c35a51c1dbf21aa136cd81">srtp_auth_type_id_t</a></td></tr>
<tr class="memdesc:gaead974fea9c35a51c1dbf21aa136cd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">An srtp_auth_type_id_t is an identifier for a particular authentication function.  <a href="#gaead974fea9c35a51c1dbf21aa136cd81">More...</a><br/></td></tr>
<tr class="separator:gaead974fea9c35a51c1dbf21aa136cd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ae6fc288a1347433a1a6c549f85ebf"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaf3ae6fc288a1347433a1a6c549f85ebf">srtp_crypto_policy_t</a></td></tr>
<tr class="memdesc:gaf3ae6fc288a1347433a1a6c549f85ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> describes a particular crypto policy that can be applied to an SRTP stream.  <a href="#gaf3ae6fc288a1347433a1a6c549f85ebf">More...</a><br/></td></tr>
<tr class="separator:gaf3ae6fc288a1347433a1a6c549f85ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1898c4cdfaa513e91ee48a6b8b84ac41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1898c4cdfaa513e91ee48a6b8b84ac41"></a>
typedef struct <br class="typebreak"/>
srtp_ekt_policy_ctx_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga1898c4cdfaa513e91ee48a6b8b84ac41">srtp_ekt_policy_t</a></td></tr>
<tr class="memdesc:ga1898c4cdfaa513e91ee48a6b8b84ac41"><td class="mdescLeft">&#160;</td><td class="mdescRight">points to an EKT policy <br/></td></tr>
<tr class="separator:ga1898c4cdfaa513e91ee48a6b8b84ac41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga505bbf545ed123ea34dfff8dc67694bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga505bbf545ed123ea34dfff8dc67694bd"></a>
typedef struct <br class="typebreak"/>
srtp_ekt_stream_ctx_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga505bbf545ed123ea34dfff8dc67694bd">srtp_ekt_stream_t</a></td></tr>
<tr class="memdesc:ga505bbf545ed123ea34dfff8dc67694bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">points to EKT stream data <br/></td></tr>
<tr class="separator:ga505bbf545ed123ea34dfff8dc67694bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5618cc5b0277b480c3a0adeac8c3e6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf5618cc5b0277b480c3a0adeac8c3e6a"></a>
typedef struct <a class="el" href="structsrtp__master__key__t.html">srtp_master_key_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaf5618cc5b0277b480c3a0adeac8c3e6a">srtp_master_key_t</a></td></tr>
<tr class="memdesc:gaf5618cc5b0277b480c3a0adeac8c3e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsrtp__master__key__t.html" title="srtp_master_key_t represents a master key. There will be a Master Key Index and the Master Key associ...">srtp_master_key_t</a> represents a master key. There will be a Master Key Index and the Master Key associated with the Master Key Index. Need to also keep track of the Master Key Index Size to correctly read it from a packet. <br/></td></tr>
<tr class="separator:gaf5618cc5b0277b480c3a0adeac8c3e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba9d83838f3bf3cbfcf6873d9989152c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaba9d83838f3bf3cbfcf6873d9989152c">srtp_policy_t</a></td></tr>
<tr class="memdesc:gaba9d83838f3bf3cbfcf6873d9989152c"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the policy for an SRTP session.  <a href="#gaba9d83838f3bf3cbfcf6873d9989152c">More...</a><br/></td></tr>
<tr class="separator:gaba9d83838f3bf3cbfcf6873d9989152c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c404a756add908efb805d6b729994d0"><td class="memItemLeft" align="right" valign="top">typedef srtp_ctx_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a></td></tr>
<tr class="memdesc:ga1c404a756add908efb805d6b729994d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An srtp_t points to an SRTP session structure.  <a href="#ga1c404a756add908efb805d6b729994d0">More...</a><br/></td></tr>
<tr class="separator:ga1c404a756add908efb805d6b729994d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2d9e365ccac332e03bf4a37e6b84ad76"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> { <br/>
&#160;&#160;<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a752f86b6b25b277fe33fcd7b33ea97ad">srtp_err_status_ok</a> = 0, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a98c0e594042b457f296d161679ca8529">srtp_err_status_fail</a> = 1, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a760df9288582172c27f23513f535187d">srtp_err_status_bad_param</a> = 2, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76af2aef9e69ff74fcc28ef0f2485f6cd75">srtp_err_status_alloc_fail</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76aecb69cd0e17d41c70565117af9f8851a">srtp_err_status_dealloc_fail</a> = 4, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a4335830b0a1051a23a0defb2ed0cd700">srtp_err_status_init_fail</a> = 5, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a89972f85963ee6f8701b6dec539c310e">srtp_err_status_terminus</a> = 6, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a3752d87e895909907c1a03dc171265d1">srtp_err_status_auth_fail</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a8465be6d106f0a0b5d5de382e7416120">srtp_err_status_cipher_fail</a> = 8, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a54645a54dab5cde2ed5581474cca070e">srtp_err_status_replay_fail</a> = 9, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a9046e80eb185b2a1dd6bd05ef5be1543">srtp_err_status_replay_old</a> = 10, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76aaffe07abd6795c0a6184d2b30a014396">srtp_err_status_algo_fail</a> = 11, 
<br/>
&#160;&#160;<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76ad91c5f661052e3e3bc54d376cc92dd0a">srtp_err_status_no_such_op</a> = 12, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76ae6f35dbfbdab7880e8b771527593fe97">srtp_err_status_no_ctx</a> = 13, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a4c52b2de43392a535aff94c825082190">srtp_err_status_cant_check</a> = 14, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76afac3dcb9166e6e5ca19ffed3edfaec9f">srtp_err_status_key_expired</a> = 15, 
<br/>
&#160;&#160;<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a097d8b1122a0f0acb6b89cf3dea8902b">srtp_err_status_socket_err</a> = 16, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a83c9215819f3bd0d8b79ef6aa66ded25">srtp_err_status_signal_err</a> = 17, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76abd39565cb766873879cb478adf29c1d1">srtp_err_status_nonce_bad</a> = 18, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a21aa5044f9d0eed1b807a9b882af9612">srtp_err_status_read_fail</a> = 19, 
<br/>
&#160;&#160;<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a002601901f33bb0f305f2412f48c850b">srtp_err_status_write_fail</a> = 20, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a03fb9eb98b0f3c286065acad9e11f1ca">srtp_err_status_parse_err</a> = 21, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a4c3886922d174041538f784961099b9b">srtp_err_status_encode_err</a> = 22, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a9beb338d8bfc45ea1ca994f09e54f02e">srtp_err_status_semaphore_err</a> = 23, 
<br/>
&#160;&#160;<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76adb7032dfd1b4ed1e6d883b85c7306173">srtp_err_status_pfkey_err</a> = 24, 
<a class="el" href="group__SRTP.html#gga2d9e365ccac332e03bf4a37e6b84ad76a2bf26cd9d81c3cb77959d10cfc1c65a6">srtp_err_status_bad_mki</a> = 25
<br/>
 }</td></tr>
<tr class="separator:ga2d9e365ccac332e03bf4a37e6b84ad76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa27b90c4ad1bc3e874ec8baa805528e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaa27b90c4ad1bc3e874ec8baa805528e2">srtp_sec_serv_t</a> { <a class="el" href="group__SRTP.html#ggaa27b90c4ad1bc3e874ec8baa805528e2ab266cc0430f25249e7833a5d5344bf42">sec_serv_none</a> = 0, 
<a class="el" href="group__SRTP.html#ggaa27b90c4ad1bc3e874ec8baa805528e2ae0a0f4f5c7b9b4533ab38abd423a5348">sec_serv_conf</a> = 1, 
<a class="el" href="group__SRTP.html#ggaa27b90c4ad1bc3e874ec8baa805528e2afc8d9c1297cb5012bd86a9920ac7dc54">sec_serv_auth</a> = 2, 
<a class="el" href="group__SRTP.html#ggaa27b90c4ad1bc3e874ec8baa805528e2a477f8fcf9528f1f3e2da6e19fcd9c34a">sec_serv_conf_and_auth</a> = 3
 }</td></tr>
<tr class="memdesc:gaa27b90c4ad1bc3e874ec8baa805528e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">srtp_sec_serv_t describes a set of security services.  <a href="group__SRTP.html#gaa27b90c4ad1bc3e874ec8baa805528e2">More...</a><br/></td></tr>
<tr class="separator:gaa27b90c4ad1bc3e874ec8baa805528e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f645f22b51783c17b084572a3c821a2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga5f645f22b51783c17b084572a3c821a2">srtp_ssrc_type_t</a> { <a class="el" href="group__SRTP.html#gga5f645f22b51783c17b084572a3c821a2ac0793f2f8d2a0acc853b11259254e898">ssrc_undefined</a> = 0, 
<a class="el" href="group__SRTP.html#gga5f645f22b51783c17b084572a3c821a2a8940964130d59cd0d94f31e9c7f5a195">ssrc_specific</a> = 1, 
<a class="el" href="group__SRTP.html#gga5f645f22b51783c17b084572a3c821a2ac3a03085d584c0c858fcf9bb75871a90">ssrc_any_inbound</a> = 2, 
<a class="el" href="group__SRTP.html#gga5f645f22b51783c17b084572a3c821a2a0eb41de916cf63dee5d43e9467b8b1db">ssrc_any_outbound</a> = 3
 }</td></tr>
<tr class="memdesc:ga5f645f22b51783c17b084572a3c821a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">srtp_ssrc_type_t describes the type of an SSRC.  <a href="group__SRTP.html#ga5f645f22b51783c17b084572a3c821a2">More...</a><br/></td></tr>
<tr class="separator:ga5f645f22b51783c17b084572a3c821a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf7be4aa17ae3ac2527bf8a499d13739c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaf7be4aa17ae3ac2527bf8a499d13739c">srtp_init</a> (void)</td></tr>
<tr class="memdesc:gaf7be4aa17ae3ac2527bf8a499d13739c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gaf7be4aa17ae3ac2527bf8a499d13739c" title="srtp_init() initializes the srtp library. ">srtp_init()</a> initializes the srtp library.  <a href="#gaf7be4aa17ae3ac2527bf8a499d13739c">More...</a><br/></td></tr>
<tr class="separator:gaf7be4aa17ae3ac2527bf8a499d13739c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad83a4717212841ffcc963b645511f6ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gad83a4717212841ffcc963b645511f6ab">srtp_shutdown</a> (void)</td></tr>
<tr class="memdesc:gad83a4717212841ffcc963b645511f6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gad83a4717212841ffcc963b645511f6ab" title="srtp_shutdown() de-initializes the srtp library. ">srtp_shutdown()</a> de-initializes the srtp library.  <a href="#gad83a4717212841ffcc963b645511f6ab">More...</a><br/></td></tr>
<tr class="separator:gad83a4717212841ffcc963b645511f6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed717c57385c7bf1f4369c27ac2742d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2">srtp_protect</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> ctx, void *rtp_hdr, int *len_ptr)</td></tr>
<tr class="memdesc:gaed717c57385c7bf1f4369c27ac2742d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2" title="srtp_protect() is the Secure RTP sender-side packet processing function. ">srtp_protect()</a> is the Secure RTP sender-side packet processing function.  <a href="#gaed717c57385c7bf1f4369c27ac2742d2">More...</a><br/></td></tr>
<tr class="separator:gaed717c57385c7bf1f4369c27ac2742d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade0124c01d6a11867714a43742675f11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gade0124c01d6a11867714a43742675f11">srtp_protect_mki</a> (srtp_ctx_t *ctx, void *rtp_hdr, int *pkt_octet_len, unsigned int use_mki, unsigned int mki_index)</td></tr>
<tr class="memdesc:gade0124c01d6a11867714a43742675f11"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gade0124c01d6a11867714a43742675f11" title="srtp_protect_mki() is the Secure RTP sender-side packet processing function that can utilize MKI...">srtp_protect_mki()</a> is the Secure RTP sender-side packet processing function that can utilize MKI.  <a href="#gade0124c01d6a11867714a43742675f11">More...</a><br/></td></tr>
<tr class="separator:gade0124c01d6a11867714a43742675f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4c3669a5b8cb19f3dfbdbefb90ee94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gad4c3669a5b8cb19f3dfbdbefb90ee94a">srtp_unprotect</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> ctx, void *srtp_hdr, int *len_ptr)</td></tr>
<tr class="memdesc:gad4c3669a5b8cb19f3dfbdbefb90ee94a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gad4c3669a5b8cb19f3dfbdbefb90ee94a" title="srtp_unprotect() is the Secure RTP receiver-side packet processing function. ">srtp_unprotect()</a> is the Secure RTP receiver-side packet processing function.  <a href="#gad4c3669a5b8cb19f3dfbdbefb90ee94a">More...</a><br/></td></tr>
<tr class="separator:gad4c3669a5b8cb19f3dfbdbefb90ee94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb9264e174303e7feb30f8b36be83041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gafb9264e174303e7feb30f8b36be83041">srtp_unprotect_mki</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> ctx, void *srtp_hdr, int *len_ptr, unsigned int use_mki)</td></tr>
<tr class="memdesc:gafb9264e174303e7feb30f8b36be83041"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gafb9264e174303e7feb30f8b36be83041" title="srtp_unprotect_mki() is the Secure RTP receiver-side packet processing function that checks for MKI...">srtp_unprotect_mki()</a> is the Secure RTP receiver-side packet processing function that checks for MKI.  <a href="#gafb9264e174303e7feb30f8b36be83041">More...</a><br/></td></tr>
<tr class="separator:gafb9264e174303e7feb30f8b36be83041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7874ac09c2a1abf0d893566f933f477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gac7874ac09c2a1abf0d893566f933f477">srtp_create</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> *session, const <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a> *policy)</td></tr>
<tr class="memdesc:gac7874ac09c2a1abf0d893566f933f477"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gac7874ac09c2a1abf0d893566f933f477" title="srtp_create() allocates and initializes an SRTP session. ">srtp_create()</a> allocates and initializes an SRTP session.  <a href="#gac7874ac09c2a1abf0d893566f933f477">More...</a><br/></td></tr>
<tr class="separator:gac7874ac09c2a1abf0d893566f933f477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977bf16d308bbacd97dbe2e3f89b27e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga977bf16d308bbacd97dbe2e3f89b27e3">srtp_add_stream</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> session, const <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a> *policy)</td></tr>
<tr class="memdesc:ga977bf16d308bbacd97dbe2e3f89b27e3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga977bf16d308bbacd97dbe2e3f89b27e3" title="srtp_add_stream() allocates and initializes an SRTP stream within a given SRTP session. ">srtp_add_stream()</a> allocates and initializes an SRTP stream within a given SRTP session.  <a href="#ga977bf16d308bbacd97dbe2e3f89b27e3">More...</a><br/></td></tr>
<tr class="separator:ga977bf16d308bbacd97dbe2e3f89b27e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9272c20fefc4ebe5b4542ab5045dd75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaa9272c20fefc4ebe5b4542ab5045dd75">srtp_remove_stream</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> session, unsigned int ssrc)</td></tr>
<tr class="memdesc:gaa9272c20fefc4ebe5b4542ab5045dd75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gaa9272c20fefc4ebe5b4542ab5045dd75" title="srtp_remove_stream() deallocates an SRTP stream. ">srtp_remove_stream()</a> deallocates an SRTP stream.  <a href="#gaa9272c20fefc4ebe5b4542ab5045dd75">More...</a><br/></td></tr>
<tr class="separator:gaa9272c20fefc4ebe5b4542ab5045dd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df26270fba355bc4fa87293c646755c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga9df26270fba355bc4fa87293c646755c">srtp_update</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> session, const <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a> *policy)</td></tr>
<tr class="memdesc:ga9df26270fba355bc4fa87293c646755c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga9df26270fba355bc4fa87293c646755c" title="srtp_update() udpates all streams in the session. ">srtp_update()</a> udpates all streams in the session.  <a href="#ga9df26270fba355bc4fa87293c646755c">More...</a><br/></td></tr>
<tr class="separator:ga9df26270fba355bc4fa87293c646755c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a062eb8bfd41afc7940252c007eca92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga1a062eb8bfd41afc7940252c007eca92">srtp_update_stream</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> session, const <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a> *policy)</td></tr>
<tr class="memdesc:ga1a062eb8bfd41afc7940252c007eca92"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga1a062eb8bfd41afc7940252c007eca92" title="srtp_update_stream() udpates a SRTP stream. ">srtp_update_stream()</a> udpates a SRTP stream.  <a href="#ga1a062eb8bfd41afc7940252c007eca92">More...</a><br/></td></tr>
<tr class="separator:ga1a062eb8bfd41afc7940252c007eca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5283f0bcdd44be2ec314077f74d831b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga5283f0bcdd44be2ec314077f74d831b0">srtp_crypto_policy_set_rtp_default</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:ga5283f0bcdd44be2ec314077f74d831b0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga5283f0bcdd44be2ec314077f74d831b0" title="srtp_crypto_policy_set_rtp_default() sets a crypto policy structure to the SRTP default policy for RT...">srtp_crypto_policy_set_rtp_default()</a> sets a crypto policy structure to the SRTP default policy for RTP protection.  <a href="#ga5283f0bcdd44be2ec314077f74d831b0">More...</a><br/></td></tr>
<tr class="separator:ga5283f0bcdd44be2ec314077f74d831b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga265e7d332804da1f823d68042192bc45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga265e7d332804da1f823d68042192bc45">srtp_crypto_policy_set_rtcp_default</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:ga265e7d332804da1f823d68042192bc45"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga265e7d332804da1f823d68042192bc45" title="srtp_crypto_policy_set_rtcp_default() sets a crypto policy structure to the SRTP default policy for R...">srtp_crypto_policy_set_rtcp_default()</a> sets a crypto policy structure to the SRTP default policy for RTCP protection.  <a href="#ga265e7d332804da1f823d68042192bc45">More...</a><br/></td></tr>
<tr class="separator:ga265e7d332804da1f823d68042192bc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d556bb1177798ecc5ddf2a9b3a21245"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga6d556bb1177798ecc5ddf2a9b3a21245">srtp_crypto_policy_set_aes_cm_128_hmac_sha1_32</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:ga6d556bb1177798ecc5ddf2a9b3a21245"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga6d556bb1177798ecc5ddf2a9b3a21245" title="srtp_crypto_policy_set_aes_cm_128_hmac_sha1_32() sets a crypto policy structure to a short-authentica...">srtp_crypto_policy_set_aes_cm_128_hmac_sha1_32()</a> sets a crypto policy structure to a short-authentication tag policy  <a href="#ga6d556bb1177798ecc5ddf2a9b3a21245">More...</a><br/></td></tr>
<tr class="separator:ga6d556bb1177798ecc5ddf2a9b3a21245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8a2d3d2bc328cccd39f312499b4bb40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gad8a2d3d2bc328cccd39f312499b4bb40">srtp_crypto_policy_set_aes_cm_128_null_auth</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:gad8a2d3d2bc328cccd39f312499b4bb40"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gad8a2d3d2bc328cccd39f312499b4bb40" title="srtp_crypto_policy_set_aes_cm_128_null_auth() sets a crypto policy structure to an encryption-only po...">srtp_crypto_policy_set_aes_cm_128_null_auth()</a> sets a crypto policy structure to an encryption-only policy  <a href="#gad8a2d3d2bc328cccd39f312499b4bb40">More...</a><br/></td></tr>
<tr class="separator:gad8a2d3d2bc328cccd39f312499b4bb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7723203d9fe8b3087ad6a31d6f41045e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga7723203d9fe8b3087ad6a31d6f41045e">srtp_crypto_policy_set_null_cipher_hmac_sha1_80</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:ga7723203d9fe8b3087ad6a31d6f41045e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga7723203d9fe8b3087ad6a31d6f41045e" title="srtp_crypto_policy_set_null_cipher_hmac_sha1_80() sets a crypto policy structure to an authentication...">srtp_crypto_policy_set_null_cipher_hmac_sha1_80()</a> sets a crypto policy structure to an authentication-only policy  <a href="#ga7723203d9fe8b3087ad6a31d6f41045e">More...</a><br/></td></tr>
<tr class="separator:ga7723203d9fe8b3087ad6a31d6f41045e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf04ea431af96a92a28d590ea0cd1cd90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaf04ea431af96a92a28d590ea0cd1cd90">srtp_crypto_policy_set_null_cipher_hmac_null</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:gaf04ea431af96a92a28d590ea0cd1cd90"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gaf04ea431af96a92a28d590ea0cd1cd90" title="srtp_crypto_policy_set_null_cipher_hmac_null() sets a crypto policy structure to use no encryption or...">srtp_crypto_policy_set_null_cipher_hmac_null()</a> sets a crypto policy structure to use no encryption or authentication.  <a href="#gaf04ea431af96a92a28d590ea0cd1cd90">More...</a><br/></td></tr>
<tr class="separator:gaf04ea431af96a92a28d590ea0cd1cd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e545a0be9dd959ab86f902bf6a037e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gac7e545a0be9dd959ab86f902bf6a037e">srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:gac7e545a0be9dd959ab86f902bf6a037e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gac7e545a0be9dd959ab86f902bf6a037e" title="srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80() sets a crypto policy structure to a encryption and a...">srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80()</a> sets a crypto policy structure to a encryption and authentication policy using AES-256 for RTP protection.  <a href="#gac7e545a0be9dd959ab86f902bf6a037e">More...</a><br/></td></tr>
<tr class="separator:gac7e545a0be9dd959ab86f902bf6a037e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e550d7ed1d08149b9932cbed933481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga63e550d7ed1d08149b9932cbed933481">srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:ga63e550d7ed1d08149b9932cbed933481"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga63e550d7ed1d08149b9932cbed933481" title="srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32() sets a crypto policy structure to a short-authentica...">srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32()</a> sets a crypto policy structure to a short-authentication tag policy using AES-256 encryption.  <a href="#ga63e550d7ed1d08149b9932cbed933481">More...</a><br/></td></tr>
<tr class="separator:ga63e550d7ed1d08149b9932cbed933481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f07f5f3b785cf9b24322a8b0736099a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga3f07f5f3b785cf9b24322a8b0736099a">srtp_crypto_policy_set_aes_cm_256_null_auth</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:ga3f07f5f3b785cf9b24322a8b0736099a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga3f07f5f3b785cf9b24322a8b0736099a" title="srtp_crypto_policy_set_aes_cm_256_null_auth() sets a crypto policy structure to an encryption-only po...">srtp_crypto_policy_set_aes_cm_256_null_auth()</a> sets a crypto policy structure to an encryption-only policy  <a href="#ga3f07f5f3b785cf9b24322a8b0736099a">More...</a><br/></td></tr>
<tr class="separator:ga3f07f5f3b785cf9b24322a8b0736099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga524169a05bd447457f71ca8294d7eea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga524169a05bd447457f71ca8294d7eea6">srtp_crypto_policy_set_aes_gcm_128_8_auth</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:ga524169a05bd447457f71ca8294d7eea6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga524169a05bd447457f71ca8294d7eea6" title="srtp_crypto_policy_set_aes_gcm_128_8_auth() sets a crypto policy structure to an AEAD encryption poli...">srtp_crypto_policy_set_aes_gcm_128_8_auth()</a> sets a crypto policy structure to an AEAD encryption policy.  <a href="#ga524169a05bd447457f71ca8294d7eea6">More...</a><br/></td></tr>
<tr class="separator:ga524169a05bd447457f71ca8294d7eea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea777fb86d3469543985f7ea86adbe14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaea777fb86d3469543985f7ea86adbe14">srtp_crypto_policy_set_aes_gcm_256_8_auth</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:gaea777fb86d3469543985f7ea86adbe14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gaea777fb86d3469543985f7ea86adbe14" title="srtp_crypto_policy_set_aes_gcm_256_8_auth() sets a crypto policy structure to an AEAD encryption poli...">srtp_crypto_policy_set_aes_gcm_256_8_auth()</a> sets a crypto policy structure to an AEAD encryption policy  <a href="#gaea777fb86d3469543985f7ea86adbe14">More...</a><br/></td></tr>
<tr class="separator:gaea777fb86d3469543985f7ea86adbe14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb45564a9c51b87539b0ece7cd5024c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaeb45564a9c51b87539b0ece7cd5024c4">srtp_crypto_policy_set_aes_gcm_128_8_only_auth</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:gaeb45564a9c51b87539b0ece7cd5024c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gaeb45564a9c51b87539b0ece7cd5024c4" title="srtp_crypto_policy_set_aes_gcm_128_8_only_auth() sets a crypto policy structure to an AEAD authentica...">srtp_crypto_policy_set_aes_gcm_128_8_only_auth()</a> sets a crypto policy structure to an AEAD authentication-only policy  <a href="#gaeb45564a9c51b87539b0ece7cd5024c4">More...</a><br/></td></tr>
<tr class="separator:gaeb45564a9c51b87539b0ece7cd5024c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga615f1b43028ee5a3287bc7caf5bb51eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga615f1b43028ee5a3287bc7caf5bb51eb">srtp_crypto_policy_set_aes_gcm_256_8_only_auth</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:ga615f1b43028ee5a3287bc7caf5bb51eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga615f1b43028ee5a3287bc7caf5bb51eb" title="srtp_crypto_policy_set_aes_gcm_256_8_only_auth() sets a crypto policy structure to an AEAD authentica...">srtp_crypto_policy_set_aes_gcm_256_8_only_auth()</a> sets a crypto policy structure to an AEAD authentication-only policy  <a href="#ga615f1b43028ee5a3287bc7caf5bb51eb">More...</a><br/></td></tr>
<tr class="separator:ga615f1b43028ee5a3287bc7caf5bb51eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6238a47c1afbe30e655e5fd5e25a765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gae6238a47c1afbe30e655e5fd5e25a765">srtp_crypto_policy_set_aes_gcm_128_16_auth</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:gae6238a47c1afbe30e655e5fd5e25a765"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#gae6238a47c1afbe30e655e5fd5e25a765" title="srtp_crypto_policy_set_aes_gcm_128_16_auth() sets a crypto policy structure to an AEAD encryption pol...">srtp_crypto_policy_set_aes_gcm_128_16_auth()</a> sets a crypto policy structure to an AEAD encryption policy.  <a href="#gae6238a47c1afbe30e655e5fd5e25a765">More...</a><br/></td></tr>
<tr class="separator:gae6238a47c1afbe30e655e5fd5e25a765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6d45192d68abe158190ae7d43a7a6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga3e6d45192d68abe158190ae7d43a7a6e">srtp_crypto_policy_set_aes_gcm_256_16_auth</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *p)</td></tr>
<tr class="memdesc:ga3e6d45192d68abe158190ae7d43a7a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga3e6d45192d68abe158190ae7d43a7a6e" title="srtp_crypto_policy_set_aes_gcm_256_16_auth() sets a crypto policy structure to an AEAD encryption pol...">srtp_crypto_policy_set_aes_gcm_256_16_auth()</a> sets a crypto policy structure to an AEAD encryption policy  <a href="#ga3e6d45192d68abe158190ae7d43a7a6e">More...</a><br/></td></tr>
<tr class="separator:ga3e6d45192d68abe158190ae7d43a7a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8793a7b37d8dd2350bd1e79c8f3ce01b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga8793a7b37d8dd2350bd1e79c8f3ce01b">srtp_dealloc</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> s)</td></tr>
<tr class="memdesc:ga8793a7b37d8dd2350bd1e79c8f3ce01b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga8793a7b37d8dd2350bd1e79c8f3ce01b" title="srtp_dealloc() deallocates storage for an SRTP session context. ">srtp_dealloc()</a> deallocates storage for an SRTP session context.  <a href="#ga8793a7b37d8dd2350bd1e79c8f3ce01b">More...</a><br/></td></tr>
<tr class="separator:ga8793a7b37d8dd2350bd1e79c8f3ce01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e69414d7ec12021409da8c8c14538b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga27e69414d7ec12021409da8c8c14538b">srtp_crypto_policy_set_from_profile_for_rtp</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *policy, srtp_profile_t profile)</td></tr>
<tr class="memdesc:ga27e69414d7ec12021409da8c8c14538b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga27e69414d7ec12021409da8c8c14538b" title="srtp_crypto_policy_set_from_profile_for_rtp() sets a crypto policy structure to the appropriate value...">srtp_crypto_policy_set_from_profile_for_rtp()</a> sets a crypto policy structure to the appropriate value for RTP based on an srtp_profile_t  <a href="#ga27e69414d7ec12021409da8c8c14538b">More...</a><br/></td></tr>
<tr class="separator:ga27e69414d7ec12021409da8c8c14538b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80aa7be2f513dbc71f6a5184736443da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga80aa7be2f513dbc71f6a5184736443da">srtp_crypto_policy_set_from_profile_for_rtcp</a> (<a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *policy, srtp_profile_t profile)</td></tr>
<tr class="memdesc:ga80aa7be2f513dbc71f6a5184736443da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTP.html#ga80aa7be2f513dbc71f6a5184736443da" title="srtp_crypto_policy_set_from_profile_for_rtcp() sets a crypto policy structure to the appropriate valu...">srtp_crypto_policy_set_from_profile_for_rtcp()</a> sets a crypto policy structure to the appropriate value for RTCP based on an srtp_profile_t  <a href="#ga80aa7be2f513dbc71f6a5184736443da">More...</a><br/></td></tr>
<tr class="separator:ga80aa7be2f513dbc71f6a5184736443da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef20ef9e53a004be005892b3bed3f0c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaef20ef9e53a004be005892b3bed3f0c9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#gaef20ef9e53a004be005892b3bed3f0c9">srtp_profile_get_master_key_length</a> (srtp_profile_t profile)</td></tr>
<tr class="memdesc:gaef20ef9e53a004be005892b3bed3f0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the master key length for a given SRTP profile <br/></td></tr>
<tr class="separator:gaef20ef9e53a004be005892b3bed3f0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd9fdc59e141884b814de7e581b7ddf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3bd9fdc59e141884b814de7e581b7ddf"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga3bd9fdc59e141884b814de7e581b7ddf">srtp_profile_get_master_salt_length</a> (srtp_profile_t profile)</td></tr>
<tr class="memdesc:ga3bd9fdc59e141884b814de7e581b7ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the master salt length for a given SRTP profile <br/></td></tr>
<tr class="separator:ga3bd9fdc59e141884b814de7e581b7ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07e568c0787448fc28a97f3ea2428ad2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTP.html#ga07e568c0787448fc28a97f3ea2428ad2">srtp_append_salt_to_key</a> (unsigned char *key, unsigned int bytes_in_key, unsigned char *salt, unsigned int bytes_in_salt)</td></tr>
<tr class="memdesc:ga07e568c0787448fc28a97f3ea2428ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">appends the salt to the key  <a href="#ga07e568c0787448fc28a97f3ea2428ad2">More...</a><br/></td></tr>
<tr class="separator:ga07e568c0787448fc28a97f3ea2428ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga3cf54c39ee78e2b6557c7e18b6e8afaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define srtp_crypto_policy_set_aes_cm_128_hmac_sha1_80</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__SRTP.html#ga5283f0bcdd44be2ec314077f74d831b0">srtp_crypto_policy_set_rtp_default</a>(p)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function <a class="el" href="group__SRTP.html#ga3cf54c39ee78e2b6557c7e18b6e8afaf" title="srtp_crypto_policy_set_aes_cm_128_hmac_sha1_80() sets a crypto policy structure to the SRTP default p...">srtp_crypto_policy_set_aes_cm_128_hmac_sha1_80()</a> is a synonym for <a class="el" href="group__SRTP.html#ga5283f0bcdd44be2ec314077f74d831b0" title="srtp_crypto_policy_set_rtp_default() sets a crypto policy structure to the SRTP default policy for RT...">srtp_crypto_policy_set_rtp_default()</a>. It conforms to the naming convention used in RFC 4568 (SDP Security Descriptions for Media Streams).</p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ga968bd496a57f1fed0f57f98e4264b0cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SRTP_MAX_MKI_LEN&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SRTP_MAX_MKI_LEN is the maximum size the MKI could be which is 128 bytes </p>

</div>
</div>
<a class="anchor" id="ga65aa1c514841041428b54a629858217e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SRTP_MAX_NUM_MASTER_KEYS&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SRTP_MAX_NUM_MASTER_KEYS is the maximum number of Master keys for MKI supported by libSRTP. </p>

</div>
</div>
<a class="anchor" id="ga0737277d812a75053bd4f6446cb88b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SRTP_MAX_TRAILER_LEN&#160;&#160;&#160;SRTP_MAX_TAG_LEN + <a class="el" href="group__SRTP.html#ga968bd496a57f1fed0f57f98e4264b0cc">SRTP_MAX_MKI_LEN</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SRTP_MAX_TRAILER_LEN is the maximum length of the SRTP trailer (authentication tag and MKI) supported by libSRTP. This value is the maixmum number of octets that will be added to an RTP packet by <a class="el" href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2" title="srtp_protect() is the Secure RTP sender-side packet processing function. ">srtp_protect()</a>. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaead974fea9c35a51c1dbf21aa136cd81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__SRTP.html#gaead974fea9c35a51c1dbf21aa136cd81">srtp_auth_type_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An srtp_auth_type_id_t is an integer that represents a particular authentication function type, e.g. HMAC-SHA1. A SRTP_NULL_AUTH is avaliable; this authentication function performs no computation, and can be selected to indicate that no authentication is to take place. </p>

</div>
</div>
<a class="anchor" id="gad70c97ce681acb694ce3caee0c1051e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__SRTP.html#gad70c97ce681acb694ce3caee0c1051e4">srtp_cipher_type_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A srtp_cipher_type_id_t is an integer that represents a particular cipher type, e.g. the Advanced Encryption Standard (AES). A SRTP_NULL_CIPHER is avaliable; this cipher leaves the data unchanged, and can be selected to indicate that no encryption is to take place. </p>

</div>
</div>
<a class="anchor" id="gaf3ae6fc288a1347433a1a6c549f85ebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a>  <a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> describes a particular cryptographic policy that can be applied to an SRTP or SRTCP stream. An SRTP session policy consists of a list of these policies, one for each SRTP stream in the session. </p>

</div>
</div>
<a class="anchor" id="gaba9d83838f3bf3cbfcf6873d9989152c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a>  <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A single <a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session. ">srtp_policy_t</a> struct represents the policy for a single SRTP stream, and a linked list of these elements represents the policy for an entire SRTP session. Each element contains the SRTP and SRTCP crypto policies for that stream, a pointer to the SRTP master key for that stream, the SSRC describing that stream, or a flag indicating a `wildcard' SSRC value, and a `next' field that holds a pointer to the next element in the list of policy elements, or NULL if it is the last element.</p>
<p>The wildcard value SSRC_ANY_INBOUND matches any SSRC from an inbound stream that for which there is no explicit SSRC entry in another policy element. Similarly, the value SSRC_ANY_OUTBOUND will matches any SSRC from an outbound stream that does not appear in another policy element. Note that wildcard SSRCs &amp;b cannot be used to match both inbound and outbound traffic. This restriction is intentional, and it allows libSRTP to ensure that no security lapses result from accidental re-use of SSRC values during key sharing.</p>
<dl class="section warning"><dt>Warning</dt><dd>The final element of the list <b>must</b> have its `next' pointer set to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c404a756add908efb805d6b729994d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef srtp_ctx_t* <a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The typedef srtp_t is a pointer to a structure that represents an SRTP session. This datatype is intentially opaque in order to separate the interface from the implementation.</p>
<p>An SRTP session consists of all of the traffic sent to the RTP and RTCP destination transport addresses, using the RTP/SAVP (Secure Audio/Video Profile). A session can be viewed as a set of SRTP streams, each of which originates with a different participant. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga2d9e365ccac332e03bf4a37e6b84ad76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a752f86b6b25b277fe33fcd7b33ea97ad"></a>srtp_err_status_ok</em>&#160;</td><td class="fielddoc">
<p>nothing to report </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a98c0e594042b457f296d161679ca8529"></a>srtp_err_status_fail</em>&#160;</td><td class="fielddoc">
<p>unspecified failure </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a760df9288582172c27f23513f535187d"></a>srtp_err_status_bad_param</em>&#160;</td><td class="fielddoc">
<p>unsupported parameter </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76af2aef9e69ff74fcc28ef0f2485f6cd75"></a>srtp_err_status_alloc_fail</em>&#160;</td><td class="fielddoc">
<p>couldn't allocate memory </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76aecb69cd0e17d41c70565117af9f8851a"></a>srtp_err_status_dealloc_fail</em>&#160;</td><td class="fielddoc">
<p>couldn't deallocate properly </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a4335830b0a1051a23a0defb2ed0cd700"></a>srtp_err_status_init_fail</em>&#160;</td><td class="fielddoc">
<p>couldn't initialize </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a89972f85963ee6f8701b6dec539c310e"></a>srtp_err_status_terminus</em>&#160;</td><td class="fielddoc">
<p>can't process as much data as requested </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a3752d87e895909907c1a03dc171265d1"></a>srtp_err_status_auth_fail</em>&#160;</td><td class="fielddoc">
<p>authentication failure </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a8465be6d106f0a0b5d5de382e7416120"></a>srtp_err_status_cipher_fail</em>&#160;</td><td class="fielddoc">
<p>cipher failure </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a54645a54dab5cde2ed5581474cca070e"></a>srtp_err_status_replay_fail</em>&#160;</td><td class="fielddoc">
<p>replay check failed (bad index) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a9046e80eb185b2a1dd6bd05ef5be1543"></a>srtp_err_status_replay_old</em>&#160;</td><td class="fielddoc">
<p>replay check failed (index too old) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76aaffe07abd6795c0a6184d2b30a014396"></a>srtp_err_status_algo_fail</em>&#160;</td><td class="fielddoc">
<p>algorithm failed test routine </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76ad91c5f661052e3e3bc54d376cc92dd0a"></a>srtp_err_status_no_such_op</em>&#160;</td><td class="fielddoc">
<p>unsupported operation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76ae6f35dbfbdab7880e8b771527593fe97"></a>srtp_err_status_no_ctx</em>&#160;</td><td class="fielddoc">
<p>no appropriate context found </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a4c52b2de43392a535aff94c825082190"></a>srtp_err_status_cant_check</em>&#160;</td><td class="fielddoc">
<p>unable to perform desired validation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76afac3dcb9166e6e5ca19ffed3edfaec9f"></a>srtp_err_status_key_expired</em>&#160;</td><td class="fielddoc">
<p>can't use key any more </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a097d8b1122a0f0acb6b89cf3dea8902b"></a>srtp_err_status_socket_err</em>&#160;</td><td class="fielddoc">
<p>error in use of socket </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a83c9215819f3bd0d8b79ef6aa66ded25"></a>srtp_err_status_signal_err</em>&#160;</td><td class="fielddoc">
<p>error in use POSIX signals </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76abd39565cb766873879cb478adf29c1d1"></a>srtp_err_status_nonce_bad</em>&#160;</td><td class="fielddoc">
<p>nonce check failed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a21aa5044f9d0eed1b807a9b882af9612"></a>srtp_err_status_read_fail</em>&#160;</td><td class="fielddoc">
<p>couldn't read data </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a002601901f33bb0f305f2412f48c850b"></a>srtp_err_status_write_fail</em>&#160;</td><td class="fielddoc">
<p>couldn't write data </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a03fb9eb98b0f3c286065acad9e11f1ca"></a>srtp_err_status_parse_err</em>&#160;</td><td class="fielddoc">
<p>error parsing data </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a4c3886922d174041538f784961099b9b"></a>srtp_err_status_encode_err</em>&#160;</td><td class="fielddoc">
<p>error encoding data </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a9beb338d8bfc45ea1ca994f09e54f02e"></a>srtp_err_status_semaphore_err</em>&#160;</td><td class="fielddoc">
<p>error while using semaphores </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76adb7032dfd1b4ed1e6d883b85c7306173"></a>srtp_err_status_pfkey_err</em>&#160;</td><td class="fielddoc">
<p>error while using pfkey </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2d9e365ccac332e03bf4a37e6b84ad76a2bf26cd9d81c3cb77959d10cfc1c65a6"></a>srtp_err_status_bad_mki</em>&#160;</td><td class="fielddoc">
<p>error MKI present in packet is invalid </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaa27b90c4ad1bc3e874ec8baa805528e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SRTP.html#gaa27b90c4ad1bc3e874ec8baa805528e2">srtp_sec_serv_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A srtp_sec_serv_t enumeration is used to describe the particular security services that will be applied by a particular crypto policy (or other mechanism). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaa27b90c4ad1bc3e874ec8baa805528e2ab266cc0430f25249e7833a5d5344bf42"></a>sec_serv_none</em>&#160;</td><td class="fielddoc">
<p>no services </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaa27b90c4ad1bc3e874ec8baa805528e2ae0a0f4f5c7b9b4533ab38abd423a5348"></a>sec_serv_conf</em>&#160;</td><td class="fielddoc">
<p>confidentiality </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaa27b90c4ad1bc3e874ec8baa805528e2afc8d9c1297cb5012bd86a9920ac7dc54"></a>sec_serv_auth</em>&#160;</td><td class="fielddoc">
<p>authentication </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaa27b90c4ad1bc3e874ec8baa805528e2a477f8fcf9528f1f3e2da6e19fcd9c34a"></a>sec_serv_conf_and_auth</em>&#160;</td><td class="fielddoc">
<p>confidentiality and authentication </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga5f645f22b51783c17b084572a3c821a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SRTP.html#ga5f645f22b51783c17b084572a3c821a2">srtp_ssrc_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An srtp_ssrc_type_t enumeration is used to indicate a type of SSRC. See <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a> for more informataion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga5f645f22b51783c17b084572a3c821a2ac0793f2f8d2a0acc853b11259254e898"></a>ssrc_undefined</em>&#160;</td><td class="fielddoc">
<p>Indicates an undefined SSRC type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5f645f22b51783c17b084572a3c821a2a8940964130d59cd0d94f31e9c7f5a195"></a>ssrc_specific</em>&#160;</td><td class="fielddoc">
<p>Indicates a specific SSRC value </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5f645f22b51783c17b084572a3c821a2ac3a03085d584c0c858fcf9bb75871a90"></a>ssrc_any_inbound</em>&#160;</td><td class="fielddoc">
<p>Indicates any inbound SSRC value (i.e. a value that is used in the function <a class="el" href="group__SRTP.html#gad4c3669a5b8cb19f3dfbdbefb90ee94a" title="srtp_unprotect() is the Secure RTP receiver-side packet processing function. ">srtp_unprotect()</a>) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5f645f22b51783c17b084572a3c821a2a0eb41de916cf63dee5d43e9467b8b1db"></a>ssrc_any_outbound</em>&#160;</td><td class="fielddoc">
<p>Indicates any outbound SSRC value (i.e. a value that is used in the function <a class="el" href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2" title="srtp_protect() is the Secure RTP sender-side packet processing function. ">srtp_protect()</a>) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga977bf16d308bbacd97dbe2e3f89b27e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_add_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_add_stream(session, policy) allocates and initializes a new SRTP stream within a given, previously created session, applying the policy given as the other argument to that stream.</p>
<dl class="section return"><dt>Returns</dt><dd>values:<ul>
<li>srtp_err_status_ok if stream creation succeded.</li>
<li>srtp_err_status_alloc_fail if stream allocation failed</li>
<li>srtp_err_status_init_fail if stream initialization failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga07e568c0787448fc28a97f3ea2428ad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_append_salt_to_key </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bytes_in_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>salt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bytes_in_salt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_append_salt_to_key(k, klen, s, slen) copies the string s to the location at klen bytes following the location k.</p>
<dl class="section warning"><dt>Warning</dt><dd>There must be at least bytes_in_salt + bytes_in_key bytes available at the location pointed to by key. </dd></dl>

</div>
</div>
<a class="anchor" id="gac7874ac09c2a1abf0d893566f933f477"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_create(session, policy) allocates and initializes an SRTP session context, applying the given policy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>is a pointer to the SRTP session to which the policy is to be added.</td></tr>
    <tr><td class="paramname">policy</td><td>is the <a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session. ">srtp_policy_t</a> struct that describes the policy for the session. The struct may be a single element, or it may be the head of a list, in which case each element of the list is processed. It may also be NULL, in which case streams should be added later using <a class="el" href="group__SRTP.html#ga977bf16d308bbacd97dbe2e3f89b27e3" title="srtp_add_stream() allocates and initializes an SRTP stream within a given SRTP session. ">srtp_add_stream()</a>. The final element of the list <b>must</b> have its `next' field set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok if creation succeded.</li>
<li>srtp_err_status_alloc_fail if allocation failed.</li>
<li>srtp_err_status_init_fail if initialization failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6d556bb1177798ecc5ddf2a9b3a21245"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_aes_cm_128_hmac_sha1_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_aes_cm_128_hmac_sha1_32(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use policy AES_CM_128_HMAC_SHA1_32 as defined in RFC 4568. This policy uses AES-128 Counter Mode encryption and HMAC-SHA1 authentication, with an authentication tag that is only 32 bits long. This length is considered adequate only for protecting audio and video media that use a stateless playback function. See Section 7.5 of RFC 3711 (<a href="http://www.ietf.org/rfc/rfc3711.txt">http://www.ietf.org/rfc/rfc3711.txt</a>).</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section warning"><dt>Warning</dt><dd>This crypto policy is intended for use in SRTP, but not in SRTCP. It is recommended that a policy that uses longer authentication tags be used for SRTCP. See Section 7.5 of RFC 3711 (<a href="http://www.ietf.org/rfc/rfc3711.txt">http://www.ietf.org/rfc/rfc3711.txt</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="gad8a2d3d2bc328cccd39f312499b4bb40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_aes_cm_128_null_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_aes_cm_128_null_auth(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use the SRTP default cipher (AES-128 Counter Mode), but to use no authentication method. This policy is NOT RECOMMENDED unless it is unavoidable; see Section 7.5 of RFC 3711 (<a href="http://www.ietf.org/rfc/rfc3711.txt">http://www.ietf.org/rfc/rfc3711.txt</a>).</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section warning"><dt>Warning</dt><dd>This policy is NOT RECOMMENDED for SRTP unless it is unavoidable, and it is NOT RECOMMENDED at all for SRTCP; see Section 7.5 of RFC 3711 (<a href="http://www.ietf.org/rfc/rfc3711.txt">http://www.ietf.org/rfc/rfc3711.txt</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ga63e550d7ed1d08149b9932cbed933481"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use policy AES_CM_256_HMAC_SHA1_32 as defined in draft-ietf-avt-srtp-big-aes-03.txt. This policy uses AES-256 Counter Mode encryption and HMAC-SHA1 authentication, with an authentication tag that is only 32 bits long. This length is considered adequate only for protecting audio and video media that use a stateless playback function. See Section 7.5 of RFC 3711 (<a href="http://www.ietf.org/rfc/rfc3711.txt">http://www.ietf.org/rfc/rfc3711.txt</a>).</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section warning"><dt>Warning</dt><dd>This crypto policy is intended for use in SRTP, but not in SRTCP. It is recommended that a policy that uses longer authentication tags be used for SRTCP. See Section 7.5 of RFC 3711 (<a href="http://www.ietf.org/rfc/rfc3711.txt">http://www.ietf.org/rfc/rfc3711.txt</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="gac7e545a0be9dd959ab86f902bf6a037e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use policy AES_CM_256_HMAC_SHA1_80 as defined in draft-ietf-avt-srtp-big-aes-03.txt. This policy uses AES-256 Counter Mode encryption and HMAC-SHA1 authentication, with an 80 bit authentication tag.</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f07f5f3b785cf9b24322a8b0736099a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_aes_cm_256_null_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_aes_cm_256_null_auth(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use the SRTP default cipher (AES-256 Counter Mode), but to use no authentication method. This policy is NOT RECOMMENDED unless it is unavoidable; see Section 7.5 of RFC 3711 (<a href="http://www.ietf.org/rfc/rfc3711.txt">http://www.ietf.org/rfc/rfc3711.txt</a>).</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section warning"><dt>Warning</dt><dd>This policy is NOT RECOMMENDED for SRTP unless it is unavoidable, and it is NOT RECOMMENDED at all for SRTCP; see Section 7.5 of RFC 3711 (<a href="http://www.ietf.org/rfc/rfc3711.txt">http://www.ietf.org/rfc/rfc3711.txt</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="gae6238a47c1afbe30e655e5fd5e25a765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_aes_gcm_128_16_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_aes_gcm_128_16_auth(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use the SRTP default cipher (AES-128 Galois Counter Mode) with 16 octet auth tag. This policy applies confidentiality and authentication to both the RTP and RTCP packets.</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ga524169a05bd447457f71ca8294d7eea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_aes_gcm_128_8_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_aes_gcm_128_8_auth(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use the SRTP default cipher (AES-128 Galois Counter Mode) with 8 octet auth tag. This policy applies confidentiality and authentication to both the RTP and RTCP packets.</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb45564a9c51b87539b0ece7cd5024c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_aes_gcm_128_8_only_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_aes_gcm_128_8_only_auth(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use the SRTP default cipher (AES-128 Galois Counter Mode) with 8 octet auth tag. This policy applies confidentiality and authentication to the RTP packets, but only authentication to the RTCP packets.</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e6d45192d68abe158190ae7d43a7a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_aes_gcm_256_16_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_aes_gcm_256_16_auth(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use the SRTP default cipher (AES-256 Galois Counter Mode) with 16 octet auth tag. This policy applies confidentiality and authentication to both the RTP and RTCP packets.</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea777fb86d3469543985f7ea86adbe14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_aes_gcm_256_8_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_aes_gcm_256_8_auth(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use the SRTP default cipher (AES-256 Galois Counter Mode) with 8 octet auth tag. This policy applies confidentiality and authentication to both the RTP and RTCP packets.</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ga615f1b43028ee5a3287bc7caf5bb51eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_aes_gcm_256_8_only_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_aes_gcm_256_8_only_auth(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use the SRTP default cipher (AES-256 Galois Counter Mode) with 8 octet auth tag. This policy applies confidentiality and authentication to the RTP packets, but only authentication to the RTCP packets.</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ga80aa7be2f513dbc71f6a5184736443da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_crypto_policy_set_from_profile_for_rtcp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">srtp_profile_t&#160;</td>
          <td class="paramname"><em>profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_rtcp_default(&amp;policy, profile) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location policy to the policy for RTCP protection, as defined by the srtp_profile_t profile.</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section return"><dt>Returns</dt><dd>values<ul>
<li>srtp_err_status_ok no problems were encountered</li>
<li>srtp_err_status_bad_param the profile is not supported </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga27e69414d7ec12021409da8c8c14538b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_crypto_policy_set_from_profile_for_rtp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">srtp_profile_t&#160;</td>
          <td class="paramname"><em>profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_rtp_default(&amp;policy, profile) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location policy to the policy for RTP protection, as defined by the srtp_profile_t profile.</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section return"><dt>Returns</dt><dd>values<ul>
<li>srtp_err_status_ok no problems were encountered</li>
<li>srtp_err_status_bad_param the profile is not supported </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf04ea431af96a92a28d590ea0cd1cd90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_null_cipher_hmac_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_null_cipher_hmac_null(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use no encryption and no authentication. This policy should only be used for testing and troubleshootingl.</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section warning"><dt>Warning</dt><dd>This policy is NOT RECOMMENDED for SRTP unless there is a requirement to forego encryption and authentication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7723203d9fe8b3087ad6a31d6f41045e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_null_cipher_hmac_sha1_80 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_null_cipher_hmac_sha1_80(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to use HMAC-SHA1 with an 80 bit authentication tag to provide message authentication, but to use no encryption. This policy is NOT RECOMMENDED for SRTP unless there is a requirement to forego encryption.</p>
<p>This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section warning"><dt>Warning</dt><dd>This policy is NOT RECOMMENDED for SRTP unless there is a requirement to forego encryption.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ga265e7d332804da1f823d68042192bc45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_rtcp_default </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call srtp_crypto_policy_set_rtcp_default(&amp;p) sets the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> at location p to the SRTP default policy for RTCP protection, as defined in the specification. This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the <a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream...">srtp_crypto_policy_t</a> datatype.</p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5283f0bcdd44be2ec314077f74d831b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srtp_crypto_policy_set_rtp_default </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrtp__crypto__policy__t.html">srtp_crypto_policy_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is a pointer to the policy structure to be set</td></tr>
  </table>
  </dd>
</dl>
<p>The function call crypto_policy_set_rtp_default(&amp;p) sets the crypto_policy_t at location p to the SRTP default policy for RTP protection, as defined in the specification. This function is a convenience that helps to avoid dealing directly with the policy data structure. You are encouraged to initialize policy elements with this function call. Doing so may allow your code to be forward compatible with later versions of libSRTP that include more elements in the crypto_policy_t datatype.</p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8793a7b37d8dd2350bd1e79c8f3ce01b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_dealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_dealloc(s) deallocates storage for the SRTP session context s. This function should be called no more than one time for each of the contexts allocated by the function <a class="el" href="group__SRTP.html#gac7874ac09c2a1abf0d893566f933f477" title="srtp_create() allocates and initializes an SRTP session. ">srtp_create()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the srtp_t for the session to be deallocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok if there no problems.</li>
<li>srtp_err_status_dealloc_fail a memory deallocation failure occured. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf7be4aa17ae3ac2527bf8a499d13739c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This function <b>must</b> be called before any other srtp functions. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed717c57385c7bf1f4369c27ac2742d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_protect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rtp_hdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_protect(ctx, rtp_hdr, len_ptr) applies SRTP protection to the RTP packet rtp_hdr (which has length *len_ptr) using the SRTP context ctx. If srtp_err_status_ok is returned, then rtp_hdr points to the resulting SRTP packet and *len_ptr is the number of octets in that packet; otherwise, no assumptions should be made about the value of either data elements.</p>
<p>The sequence numbers of the RTP packets presented to this function need not be consecutive, but they <b>must</b> be out of order by less than 2^15 = 32,768 packets.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that it can write the authentication tag into the location in memory immediately following the RTP packet, and assumes that the RTP packet is aligned on a 32-bit boundary.</dd>
<dd>
This function assumes that it can write SRTP_MAX_TRAILER_LEN into the location in memory immediately following the RTP packet. Callers MUST ensure that this much writable memory is available in the buffer that holds the RTP packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>is the SRTP context to use in processing the packet.</td></tr>
    <tr><td class="paramname">rtp_hdr</td><td>is a pointer to the RTP packet (before the call); after the function returns, it points to the srtp packet.</td></tr>
    <tr><td class="paramname">len_ptr</td><td>is a pointer to the length in octets of the complete RTP packet (header and body) before the function call, and of the complete SRTP packet after the call, if srtp_err_status_ok was returned. Otherwise, the value of the data to which it points is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok no problems</li>
<li>srtp_err_status_replay_fail rtp sequence number was non-increasing</li>
<li><em>other</em> failure in cryptographic mechanisms </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gade0124c01d6a11867714a43742675f11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_protect_mki </td>
          <td>(</td>
          <td class="paramtype">srtp_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rtp_hdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pkt_octet_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>use_mki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mki_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_protect(ctx, rtp_hdr, len_ptr) applies SRTP protection to the RTP packet rtp_hdr (which has length *len_ptr) using the SRTP context ctx. If srtp_err_status_ok is returned, then rtp_hdr points to the resulting SRTP packet and *len_ptr is the number of octets in that packet; otherwise, no assumptions should be made about the value of either data elements.</p>
<p>The sequence numbers of the RTP packets presented to this function need not be consecutive, but they <b>must</b> be out of order by less than 2^15 = 32,768 packets.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that it can write the authentication tag into the location in memory immediately following the RTP packet, and assumes that the RTP packet is aligned on a 32-bit boundary.</dd>
<dd>
This function assumes that it can write SRTP_MAX_TRAILER_LEN into the location in memory immediately following the RTP packet. Callers MUST ensure that this much writable memory is available in the buffer that holds the RTP packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>is the SRTP context to use in processing the packet.</td></tr>
    <tr><td class="paramname">rtp_hdr</td><td>is a pointer to the RTP packet (before the call); after the function returns, it points to the srtp packet.</td></tr>
    <tr><td class="paramname">len_ptr</td><td>is a pointer to the length in octets of the complete RTP packet (header and body) before the function call, and of the complete SRTP packet after the call, if srtp_err_status_ok was returned. Otherwise, the value of the data to which it points is undefined.</td></tr>
    <tr><td class="paramname">use_mki</td><td>is a boolean to tell the system if mki is being used. If set to false then will use the first set of session keys. If set to true will use the session keys identified by the mki_index</td></tr>
    <tr><td class="paramname">mki_index</td><td>integer value specifying which set of session kesy should be used if use_mki is set to true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok no problems</li>
<li>srtp_err_status_replay_fail rtp sequence number was non-increasing</li>
<li><em>other</em> failure in cryptographic mechanisms </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa9272c20fefc4ebe5b4542ab5045dd75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_remove_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ssrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_remove_stream(session, ssrc) removes the SRTP stream with the SSRC value ssrc from the SRTP session context given by the argument session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>is the SRTP session from which the stream will be removed.</td></tr>
    <tr><td class="paramname">ssrc</td><td>is the SSRC value of the stream to be removed in network byte order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Wildcard SSRC values cannot be removed from a session.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok if the stream deallocation succeded.</li>
<li>[other] otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad83a4717212841ffcc963b645511f6ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>No srtp functions may be called after calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4c3669a5b8cb19f3dfbdbefb90ee94a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_unprotect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>srtp_hdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_unprotect(ctx, srtp_hdr, len_ptr) verifies the Secure RTP protection of the SRTP packet pointed to by srtp_hdr (which has length *len_ptr), using the SRTP context ctx. If srtp_err_status_ok is returned, then srtp_hdr points to the resulting RTP packet and *len_ptr is the number of octets in that packet; otherwise, no assumptions should be made about the value of either data elements.</p>
<p>The sequence numbers of the RTP packets presented to this function need not be consecutive, but they <b>must</b> be out of order by less than 2^15 = 32,768 packets.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the SRTP packet is aligned on a 32-bit boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>is the SRTP session which applies to the particular packet.</td></tr>
    <tr><td class="paramname">srtp_hdr</td><td>is a pointer to the header of the SRTP packet (before the call). after the function returns, it points to the rtp packet if srtp_err_status_ok was returned; otherwise, the value of the data to which it points is undefined.</td></tr>
    <tr><td class="paramname">len_ptr</td><td>is a pointer to the length in octets of the complete srtp packet (header and body) before the function call, and of the complete rtp packet after the call, if srtp_err_status_ok was returned. Otherwise, the value of the data to which it points is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok if the RTP packet is valid.</li>
<li>srtp_err_status_auth_fail if the SRTP packet failed the message authentication check.</li>
<li>srtp_err_status_replay_fail if the SRTP packet is a replay (e.g. packet has already been processed and accepted).</li>
<li>[other] if there has been an error in the cryptographic mechanisms. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gafb9264e174303e7feb30f8b36be83041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_unprotect_mki </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>srtp_hdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>use_mki</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_unprotect(ctx, srtp_hdr, len_ptr) verifies the Secure RTP protection of the SRTP packet pointed to by srtp_hdr (which has length *len_ptr), using the SRTP context ctx. If srtp_err_status_ok is returned, then srtp_hdr points to the resulting RTP packet and *len_ptr is the number of octets in that packet; otherwise, no assumptions should be made about the value of either data elements.</p>
<p>The sequence numbers of the RTP packets presented to this function need not be consecutive, but they <b>must</b> be out of order by less than 2^15 = 32,768 packets.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the SRTP packet is aligned on a 32-bit boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>is the SRTP session which applies to the particular packet.</td></tr>
    <tr><td class="paramname">srtp_hdr</td><td>is a pointer to the header of the SRTP packet (before the call). after the function returns, it points to the rtp packet if srtp_err_status_ok was returned; otherwise, the value of the data to which it points is undefined.</td></tr>
    <tr><td class="paramname">len_ptr</td><td>is a pointer to the length in octets of the complete srtp packet (header and body) before the function call, and of the complete rtp packet after the call, if srtp_err_status_ok was returned. Otherwise, the value of the data to which it points is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok if the RTP packet is valid.</li>
<li>srtp_err_status_auth_fail if the SRTP packet failed the message authentication check.</li>
<li>srtp_err_status_replay_fail if the SRTP packet is a replay (e.g. packet has already been processed and accepted).</li>
<li>srtp_err_status_bad_mki if the MKI in the packet is not a known MKI id</li>
<li>[other] if there has been an error in the cryptographic mechanisms. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9df26270fba355bc4fa87293c646755c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_update(session, policy) updates all the streams in the session applying the given policy and key. The exsisting ROC value of all streams will be preserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>is the SRTP session that contains the streams to be updated.</td></tr>
    <tr><td class="paramname">policy</td><td>is the <a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session. ">srtp_policy_t</a> struct that describes the policy for the session. The struct may be a single element, or it may be the head of a list, in which case each element of the list is processed. The final element of the list <b>must</b> have its `next' field set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok if stream creation succeded.</li>
<li>srtp_err_status_alloc_fail if stream allocation failed</li>
<li>srtp_err_status_init_fail if stream initialization failed.</li>
<li>[other] otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1a062eb8bfd41afc7940252c007eca92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_update_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsrtp__policy__t.html">srtp_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_update_stream(session, policy) updates the stream(s) in the session that match applying the given policy and key. The exsisting ROC value of all stream(s) will be preserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>is the SRTP session that contains the streams to be updated.</td></tr>
    <tr><td class="paramname">policy</td><td>is the <a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session. ">srtp_policy_t</a> struct that describes the policy for the session.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok if stream creation succeded.</li>
<li>srtp_err_status_alloc_fail if stream allocation failed</li>
<li>srtp_err_status_init_fail if stream initialization failed.</li>
<li>[other] otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
